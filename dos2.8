; dos.8   :   MS-DOS file-related routines.

; Load file into the text buffer.
; On entry:
;    SI = start of filename, terminated by 13 or 32.
; On return:
;    AX, CX trashed.
;    SI points to 1st character after filename.
; On error:
;    Jumps to "jmp_error"
public load_file, save_file

load_file:
	mov fname,si		; store pointer to fname
	mov dx,si
	call find_space		; move SI to end of filename, AL = [SI]
	mov b[si],0		; mark end of file name
	inc si			; leave SI at next character
	cmp al,13		; See if we were at the end of the cmd line
	if z mov b[si],al	; If so, leave a CR here.
	mov al,0		; 0 = read access
	call fopen		; open file named at [dx] (set file_handle)
	jc ret			; return if file not found
	mov dx,text_top		; DX = start of buffer
	mov cx,text_limit
	sub cx,dx		; CX = text_limit - text_top  (max # of bytes)
	mov ah,03Fh		; code for Read from File function
	call dosint		; DOS call (jmp_error if error)
	cmp ax,cx
	jne >l1
	mov dx,offset msg2	; file too big
	jmp err_exit		; go to error handler
l1:	add ax,text_top
	mov text_btm,ax		; set end of text area
	call fclose
	test verbatim
	if z call remove_CRs	; remove CR's if NOT verbatim
	ret


; Advance SI to first whitespace.
; On return:
;	AL = [SI] = 13 or 32
find_space:
	lodsb		; al = *si++
	cmp al,13
	je >l1
	cmp al,32
	jne find_space
l1:	dec si
	ret


; fopen:
;	On entry, DS:DX points to file name.
;	On exit, file_handle = file's handle
;		BX = file handle
;		C set if file not found.

fopen:	mov ax,03D00h		; open file named at DX
	int 021h		; do DOS call and handle error
	jc >l1			; go if error
	mov file_handle,ax
	mov bx,ax
	ret
l1:	cmp al,2		; AL=2 indicates file not found
	jnz je1
	stc
	ret
	

fcreat:	mov ah,03Ch		; open file named at DX
;;?	mov file_handle,0	; file_handle!=0 will indicate successful open
	mov cl,0
	call dosint
	mov file_handle,ax
	mov bx,ax
	ret


fclose:	mov bx,file_handle
	mov ah,03Eh
	jmp short dosint

; Write CX bytes at DX to file handle BX.
; Modifies AH.
write_bytes:
	mov ah,040h
	;jmp dosint

; Execute int 021h and handle error.
dosint:	int 021h
	jnc ret
je1:	jmp jmp_error		; Resumes where "catch_error" was last called.


; save file to disk
;    If (!verbatim) then output all LF's as CR/LF's, using the following
; loop:
;	1. Output all bytes up to the next LF.
;	   (If no LF, output rest of the text and return).
;	2. Output CR/LF and advance past the LF.
;	3. goto 1
save_file:
	mov dx,fname			; File name is at DX
	call catch_error
	jc save_failure
	call fcreat			; open file
	call write_text
	call fclose
	mov si,msg4			; say "File saved."
l1:	mov al,hltcolor
	jmp disp_stat_col
save_failure:
	call disp_page			; fix screen after DOS "Abort...?" msg
	mov si,msg5			; say "Error saving file"
	jmp l1

write_text:
	test verbatim
	if z jmp add_CRs
	mov dx,text_top			; DX = start of data
	mov cx,text_btm
	sub cx,dx			; CX = # bytes remaining to write
	call write_bytes		;     save data DIRECTLY
	ret

; Expand all LF's to CR/LF's, save file, then remove all CR's.
; Copies text from [text_top,text_btm] to [new_top,text_limit],
; then back again.
add_CRs:
	mov di,text_limit
	mov si,text_btm

l1:	cmp si,text_top
	jbe >l9			; done
	dec si
	mov al,[si]
	dec di
	mov [di],al
	cmp al,10
	jnz l1
	dec di
	cmp di,si
	jb add_cr_abort		; di < si : Not enough room for all CR's
	mov b[di],13
	jmp l1
add_cr_abort:
	mov si,text_top
	mov di,text_top
l9:	mov dx,di		; DX = start of new copy
	mov cx,text_limit
	sub cx,dx		; CX = number of bytes
	call write_bytes
; call remove_CRs
; remove_new_crs  : Copies text from [di,text_limit] to [text_top,text_btm]
	xchg si,di		; now SI = new copy, DI = text_top
l1:	cmp si,text_limit
	jz >l9
	mov al,[si]
	inc si
	cmp al,13
	jz l1
	mov [di],al
	inc di
	jmp l1
l9:	mov text_btm, di
	ret

;-- text_btm == byte after last byte
;-- text_limit = byte after last available position
;
; while (si > text_top) {
;    mov al,[--si]
;    mov [--di],al
;    if (al==10) {
;       --di
;       if (di < si) { remove_CRs(); longjmp ERROR-OUT-OF-MEM;}
;       mov [di],13
;    }
; }
; write(fd, si, text_limit-si);
; remove_CRs();

;write_text:
;	mov dx,text_top			; DX = start of data
;	mov cx,text_btm
;	sub cx,dx			; CX = # bytes remaining to write
;	test verbatim			; If in verbatim mode, then
;	jnz write_bytes		;     save data DIRECTLY
;   ; ALWAYS at l1:
;   ;   BX = file handle
;   ;   CX = # of bytes remaining
;   ;   DX = start of block of text to write
;l1:	jcxz write_bytes		; find_lf won't work if CX = 0
;	mov di,dx			; Advance DI to byte after LF, but
;	call find_lf			;   don't move further than CX bytes.
;	jne write_bytes			; save rest of file if no LF was found
;	push di,si			; push pos after LF & count after LF
;	sub cx,si			; CX = (total) - (bytes after LF)
;	dec cx				; CX = # of bytes to LF
;	call write_bytes		; write bytes UP TO the LF
;	mov cx,2
;	mov dx,offset crlf
;	call write_bytes		; write CR/LF
;	pop cx,dx			; DX is after LF; CX = count
;	jmp l1


; advance DI to first LF
; On return:
;	AL = 10
;	SI = # remaining after LF
;	DI = position after LF
;	Z set if LF found.	( b[text_btm] must be 0. )

;find_lf:
;	push cx,es			; look for LF
;	mov es,ds
;	mov al,10			; look for LF (10)
;	repne scasb			; advance DI until 10 reached or CX=0
;	mov si,cx
;	pop es,cx
;	ret
