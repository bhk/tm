; Text area specific code:

; get_byte: Get byte in text pointed to by pointer DI
;get_byte:
;	mov al,ds:[di]
;	ret

; get_next_byte:  Get byte pointed to by pointer DI and increment DI
;	On entry:  DI = text pointer
;	On exit: AL = byte from text, DI points to next byte, C set if past
;		end of text

get_next_byte:
	;call get_byte		; do "mov al,[di]" directly
	mov al,ds:[di]
inc_ptr:
	inc di
	cmp text_btm,di
	ret


dec_ptr:
	dec di
	cmp di,text_top
	ret


; delete_after_point: delete the one byte following point
;   Saves all registers used except DI & SI
;delete_after_point:
;	mov di,point
;	mov si,di
;	inc si
	;jmp delete_di_to_si		; fall through

; delete_di_to_si : delete a block of bytes from the text.  "jmp jmp_error"
; if cut buffer is full.
; On entry:
;	DI = first byte of block
;	SI = byte after block
delete_di_to_si:		; source = SI...text_btm, destination = DI
	call save_deletion
	push cx
	mov cx,text_btm
	sub cx,si		; CX = # of bytes to move
	push es
	mov es,ds
	rep movsb		; move [SI...text_btm] to [point...?]
	mov text_btm,di
	pop es
	pop cx
	ret


; On entry:
;	DI = first byte to be deleted
;	SI = byte after last byte to be deleted
; On exit:
;	No registers changed.
save_deletion:
	test deleted		; See if cut buffer should be cleared.
	if z mov cb_size,0	; If so, write into it at zero
	push cx,di,si,es
	mov cx,si
	sub cx,di
	mov si,di		; ds:si = source
	mov di,cb_size
	add di,cx
	cmp di,cb_limit		; see if resulting size exceeds maximum
	ja >l1
	les di,cb_end		; es:di = cb_seg:cb_size = destination
	rep movsb
	mov cb_size,di
	pop es,si,di,cx
	ret
l1:	mov si,msg7		; say "Cut buffer full!"
	jmp msg_error
	

; ins_at_point
;  On return:  DI points to byte inserted,  SI points to byte before that.

ins_at_point:
	push cx
	mov cx,1
	call expand_at_point	; SI = old point-1,  DI = NEW point
	mov b[di-1],al		; save inserted byte at point
	pop cx
	ret

; Make room for CX bytes at point.  'point' is set to point + CX
; On entry:
;	CX = number of bytes to displace
; On exit:
;	SI = byte before old point, DI = point (new point)
; If not enough memory jump to "jmp_error".
expand_at_point:
	push cx,es
	mov di,text_btm
	mov si,di		; SI = current text_btm
	add di,cx		; DI = new text_btm
	jc >l5			; go if not enough memory (DI > 64K)
	cmp di,text_limit
	ja >l5			; go if DI > text_limit
	mov text_btm,di
	mov cx,si		; CX = current text_btm
	sub cx,point		; CX = # of bytes to move
	dec si			; SI = last byte in text (currently)
	dec di			; DI = new pos. for last byte in text
	mov es,ds
	std
	rep movsb
	cld
	inc di
	mov point,di
	pop es,cx
	ret
l5:	mov si,msg6		; say "text buffer full"
	jmp msg_error


;  Remove CR's from the buffer.
remove_CRs:
	push ax,di,si,es
	mov es,ds
	mov di,text_top
	mov si,di
	jmp >l2			; jump to test at end of loop
l1:	lodsb			; al = *si++
	cmp al,13
	if ne stosb		; if (al != 13) *di++ = al;
l2:	cmp si,text_btm
	jnz l1
	mov text_btm,di
	pop es,si,di,ax
	ret


; Insert cut buffer into text at point.
insert_cut:
	mov cx,cb_size		; CX = # of bytes
	call expand_at_point
	inc si
	mov di,si		; DI = old point
	clear si		; SI = start of cut buffer
	push ds,es
	mov es,ds		; ES = text buffer segment
	mov ds,cb_seg		; DS = but buffer segment
	rep movsb		; move ds:[si] to es:[di]
	pop es,ds
	ret


; Allocate space for the cut buffer and set cb_seg and cb_limit
; Preserves no registers.
cb_init:
	mov bx,ds
	add bx,4096		; 4096 * 16 = 64K   (BX = byte after code seg)
	mov cx,w[02]		; CX = segment pointer to end of memory
	sub cx,bx		; CX = top - end of code/stack segment
	jbe >l1			; No memory above code segment!
	mov cb_seg,bx
	cmp cx,4096		; See if avaible cut buffer memory > 64K
	if ae mov cx,4095	; If so, use maximum number of "paragraphs"
;extnded?	shl cx,4		; CX = CX * 16
	add cx,cx
	add cx,cx
	add cx,cx
	add cx,cx

	mov cb_limit,cx
	ret
; Not enough memory above code segment --> split text buffer
l1:	mov bx,text_limit
	mov cx,bx
	mov ax,bx
	sub cx,text_top		; CX = # of bytes in text buffer
	shr cx,6		; CX = # of paragraphs in text buffer / 4
	jz >l9			; go if not enough memory
	shr bx,4		; BX = paragraph offset of text_limit in DS
	sub bx,cx		; BX = paragraph offset for cut buffer
	mov dx,bx
	shl dx,4		; DX = byte offset of cut buffer
	mov text_limit,dx
	sub ax,dx		; AX = OLD text_limit - NEW text_limit
	mov cb_limit,ax
	mov ax,ds
	add ax,bx		; AX = paragraph offset + DS = segment address
	mov cb_seg,ax
	ret
l9:	mov dx,msg10		; say "You're screwed."
	jmp err_exit


initial_newline	db	10	; needed by certain routines
text_top	equ $

