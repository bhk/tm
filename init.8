;;; init.8 : Data & macros.  Must appear first in list of modules.

EOT_CHAR	equ 236	 ; Omega character; displayed at end of text
MXBUF_SIZE	equ 300	 ; 1 byte per keystroke, 2 per macro, 2 per nest level
SRCHBUF_SIZE	equ 32	 ; Warning: each character needs 6 bytes of stack...
FNAME_SIZE	equ 07Eh ; maximum size of file name
ARGBUF		equ 081h ; address of argument buffer; use to hold file name
TABCHAR		equ 9

;;; The data segment contains variables that overlap the once-used
;;; 3-byte jmp instruction that begins the code segment.

data segment
	org 0100h
cursor		label word
cursorX		db ?
cursorY		db ?
clrstat		db ?		; controls clearing of status line


code segment

main:	jmp start

color		db ?		; current color

EVEN

;;;
;;; **Warning**: The ordering of the following variables is significant.
;;;     Refer to the initialization logic before re-ordering.
;;;

dyn_buffers:
mxbufmax	dw ?		; see key.8
mxdefsend	dw ?
mxbuf		dw
srchbufmax	dw ?		; see srch.8
srchbuf		dw ?
fnamebuf	dw		; temp file name
textbufmax	dw ?

;;; Search state

srchend		dw ?		; ptr to end of srchbuf[]
srchdir_n_mask	dw
srchdir		db ?		; search direction
srchcsmask	db ?		; 0FF if case sensitive, 95 if not
srchtextmax	dw ?		; = textbufend - len(srchbuf)
srchmode	db ?
srcholdlen	dw 0		; 0 => no previous search string

;;; Undo state

ub_end		dq
ub_pos		dw ?
ub_seg		dw 0		; ub_init assumes ub_limit follows ub_seg.
ub_limit	dw ?
ub_undo_pos	dw ?

;;; Cut buffer

	;; The ordering of cb_eg and cb_limit is significant; see init_bufs.
cb_end		dq
cb_size		dw 0		; number of bytes in the cut buffer
cb_seg		dw ?		; segment pointer to start of cut buffer
cb_limit	dw ?		; maximum size of the cut buffer

;;; Misc.

init_level	db 0
catch_sp	dw ?		; SP saved by catch

;;; Display location

topleft		label word	; A quick way to access xoff and yoff
xoff		db 0		; (xoff,yoff) is an offset to which all other
yoff		db 0		;    (x,y) coordinates are relative.
disp_cols	db 0		; set by '-w' argument (width of window)
disp_lines	db 0		; set by '-l' argument (# lines in window)
maxX		db ?		; = disp_cols-1	(highest column # for text)
maxY		db ?		; = disp_lines-1 (highest line # for text)
hgt_and_wid	dw
scrwid		db 0		; screen width in columns (set on startup)
scrhgt		db 0		; screen height in lines (set by '-L')

screen_seg	dw
		db 0
screen_page	db 0		; If screen_page == 0 then write to screen buf
				; (When non-zero, screen_seg holds screen mem)

;;; macro state

mxptr		dw ?	; playback pointer (0 => playback off)
			; Points to character getkey will return
mxrecptr	dw ?	; record pointer  (0 => not recording)
			; mxrecptr points to next place to store a char
mxsp		dw ?	; limit for macro definitions (starts = mxbufmax)
ungotkey	db 0


;;; Editing state

targetX		db 0		; stores column for goto next/prev line fns.
verbatim	db 0		; >0 if CR's should be displayed, 0 if not
dispmode	db 0		; Specifies representation of ctrl chars


changes		label word	; Set 'unsaved' and 'deleted' at one time
unsaved		db 0		; 0FFh if there are unsaved changes
cutting		db 0		; set when the previous key added to the cut buffer
wnd_ptr		dw ?		; = Where in text the top-left of screen is.
wnd_drawn	dw ?		; value of 'wnd_ptr' at time of last draw_page
point		dw ?		; Current edit point in text (where cursor is)
text_mark	dw 0		; Current mark setting (0 indicates not set)
textbufend	dw textbuf	; Points to byte after end of text.

;;; Text display settings

defcolor	db 0Eh		; default color
inv_and_hlt	dw		; get hlt and inv at once
invcolor	db 020h		; inverse color
hltcolor	db 7		; highlighted color
tabwid		db 8		; "-tX" changes this.
crlf		db 13		; Used by opt_save.  (If newline changes,
		;db 10		; then verbatim is set & crlf won't be used!)
newline		db 10		; character denoting end of logical line (-nX)
				; If "-n.." is given, verbatim should be set!

;;; Menu definition macro

menudef MACRO ; label prompt count [vector name]+
#1:	db #2		; prompt message
	db #3		; count (number of options)
	dw #1_L		; keymap
  #ry5l
	db #y		; option names (5, 7, 9, ...)
  #e2
  #rx4l
	dw #x		; option vectors (4, 6, 8, ...)
  #e2
#1_L: db
#EM

dvect MACRO db #1, (#2 - $) #EM

jmps MACRO jmp short #1 #EM

clear MACRO sub #1, #1 #EM

shr4 MACRO shr #1, 4 #EM	; redefine to be 286 specific or not

pushi MACRO push #1 #EM		; 286 specific or not.  Since the 8086 version
				; might use AX, use this as if it trashes AX.

clc_skip1 MACRO db 0A8h #EM	; "test al,ib" : Clears carry, skips next byte

skip2 MACRO db 0a9h #EM		; "test ax, im"... next 2 bytes are imm data

ungetkey MACRO mov ungotkey, #1 #EM

jmpon MACRO
	cmp al, #1
	jz #2
#EM

;;; Bind one-byte keys to two-byte values (usually addresses)

bind MACRO #rx2l
	db  #x		; byte representing key
	dw  offset #1	; word holding associated value
  #er
#em


;;; Bind one-byte keys to one-byte values

bind_b MACRO #rx2l
	db  #x		; byte representing key
	db  #1		; word holding associated value
  #er
#em

;;; Message indices
;;;
;;; Note: srch_input relis on these properties:
;;;	msgrsrch AND 3 == msgrplc
;;;	msgsrch AND 3 == msgrplc
;;;	msgedit == 3

msgfilesaved	equ 1
msgnewfile	equ 2
msgedit		equ 3
msgcutfull	equ 4
msgmarkset	equ 5
msgmarknot	equ 6
msgaborted	equ 7
msgmxfull	equ 8
msgrecording	equ 9
msgmxdone	equ 10
msgloop		equ 11
msgrsrch	equ 12
msgfull		equ 13
msgsrch		equ 14
msgrplc		equ 15
msgtextfull	equ 16
msgnotfound	equ 17	; srch_more needs (msgnotfound > other msgs)
msgloadfile	equ 26
msgsavefile	equ 27
msgreaderror	equ 28
msgfilebig	equ 29
msgerrorsaving	equ 30
msgloaded	equ 36
msgnomore	equ 42
msgundo		equ 43
msgbanner	equ 52

dosmsg3:	db 'TM: bad argument$'
dosmsg4:	db 'TM: Not enough memory$'

msg0:	db 0
	db -39, 'd', -40, 0			;  1 Saved "<fnm>"
	db 'New', -31, -40, 0			;  2 New file: "<fnm>"
	db 'Type ^S when done...', 0		;  3 Type ^S when done...
	db 'Cut', -20, 0			;  4 Cut buffer full!
	db -21, 'set.', 0			;  5 Mark set.
	db -21, -22, 'set!', 0			;  6 Mark not set!
	db '^G', 0				;  7 ^G
	db -23, -20, 0				;  8 Macro buffer full!
	db -25, -41, -23, '...', 0		;  9 Recording macro...
	db -23, ' ', -25, -18, 0		; 10 Macro recorded.
	db -23, ' loop!', 0			; 11 Macro loop!
	db 'R-', -14, 0				; 12 R-Search:
	db -19, ' :', 0				; 13 Full! :
	db 'Search:', 0				; 14 Search:
	db -38, '? (Y,N,A,Q) :', 0		; 15 Replace? (Y, N, A, Q) :
	db -33, -20, 0				; 16 File buffer full!
	db -22, 'found:', 0			; 17 Not found:
	db 'ed.', 0				; 18 ed.
	db 'full!', 0				; 19 full!
	db ' buffer ', -19, 0			; 20  buffer full!
	db 'mark ', 0				; 21 mark
	db 'not ', 0				; 22 not
	db 'macro', 0				; 23 macro
	db 'Quit', 0				; 24 Quit
	db 'record', 0				; 25 record
	db -35, -31, 0				; 26 Load file:
	db -39, -31, 0				; 27 Save file:
	db -35, ' ', -32, '!', 0		; 28 Load error!
	db -33, ' too big!', 0			; 29 File too big!
	db -32, ' ', -34,-41,-33,'!', 0  	; 30 error saving file!
	db ' ', -33, ':', 0			; 31  file:
	db 'error', 0				; 32 error
	db 'file', 0				; 33 file
	db 'sav', 0				; 34 sav
	db 'Load', 0				; 35 Load
	db -35, 'ed', -40, 0			; 36 Loaded "FILE"
	db ' changes', 0			; 37  changes
	db 'Replace', 0				; 38 Replace
	db 'Save', 0				; 39 Save
	db ' "', -128, '"', 0			; 40 "FILE"
	db 'ing ', 0				; 41 ing
	db 'no more ', -44, '!', 0		; 42 no more undo!
	db -44, -41, '...', 0			; 43 undoing ...
	db 'undo', 0				; 44 undo
	db -24, ' and lose', -37 ,'?', 0 	; 45 Quit and lose changes?
	db -34, 'e As', 0               	; 46 save As
	db 'No', 0				; 47 No
	db 'Yes', 0				; 48 Yes
	db -35, ':', -40, ' un', -34, -18, 0	; 49 Load: "FILE" unsaved
	db -39, -37, 0				; 50 Save changes
	db 'Option:', 0                         ; 51 Option
	db 'TM 1.5', 0				; 52 TM 1.5

menudef esc_menu, 51, 4, opt_save, 39, opt_save_as, 46, opt_load, 35, opt_quit, 24
	bind_b 1, 'S', 19		; 'S' and ctrl-S execute "Save"
	bind_b 2, 'A', 23		; 'A' and ctrl-W execute "save As"
	bind_b 3, 'L', 6		; 'L' and ctrl-F execute "Load"
	bind_b 4, 'Q', 3		; 'Q' and ctrl-C execute option 2
	db 0

menudef exit_menu, 45, 3, opt_done, 47, opt_quit_y, 48, opt_quit_save, 39
	bind_b 1, 'N'
	bind_b 2, 'Y'
	bind_b 3, 'S'
	db 0

menudef load_menu, 49, 2, opt_load_save, 50, opt_replace, 38
	bind_b 1, 'S'
	bind_b 2, 'R'
	db 0


;;; Key bindings
;;;
;;; When a key is pressed, this list of bindings is searched for a
;;; function to execute.  A key is identified by its ASCII value
;;; if one is returned by BIOS; otherwise (0-scancode) is used.
;;;
;;; Each invocation of the `bind` macro may generate one *or more*
;;; (key, function) pairs.
;;;
;;; A zero key value terminates the list of bindings.

fn_bindings:
	bind do_literal, 10		; LF
	bind do_enter, 13		; Enter
	bind do_literal, 9		; tab
	bind do_backspace, 8		; BackSpace
	bind go_up, 16, -72		; ctrl-P, Up
	bind go_dn, 14, -80		; ctrl-N, Down
	bind go_lft, 2, -75		; ctrl-B, Left
	bind go_rgt, 6, -77		; ctrl-F, Right
	bind go_pgup, -73, -47		; PgUp, alt-V
	bind go_pgdn, -81, 22		; PgDn, ctrl-V
	bind go_top, -4			; ctrl-PgUp (-132 -> -4)
	bind go_btm, -118		; ctrl-PgDn
	bind go_home, 1, -71		; ctrl-A, Home
	bind go_end, 5, -79		; ctrl-E, End
	bind go_lft_word, -115, -48	; ctrl-Left, Alt-B
	bind go_rgt_word, -116, -33	; ctrl-Right, Alt-F
	bind go_scrlup, 26		; ctrl-Z
	bind go_scrldn, -44		; alt-Z
	bind do_recenter, 12		; ctrl-L
	bind do_delete, 4, -83		; ctrl-D, Delete
	bind do_kill, 11, -117		; ctrl-K, ctrl-End
	bind do_ctrlq, 17		; ctrl-Q
	bind do_esc, 24, 27		; ctrl-X, ESC
	bind do_yank, 25		; ctrl-Y
	bind do_cutappend, -30		; Alt-A
	bind do_setmark, -3		; Ctrl-@, Alt-= (-131 -> -3)
	bind do_deltomark, 23		; Ctrl-W
	bind do_fsearch, 19		; Ctrl-S
	bind do_rsearch, 18		; Ctrl-R
	bind do_xchgmark, 28		; Ctrl-\
	bind do_abort, 7		; Ctrl-G
	bind do_stripCRs, -50		; Alt-M
	bind do_twiddle, 20		; Ctrl-T
	bind do_dispmode, -34		; Alt-G
	bind do_insline, 15		; Ctrl-O
	bind do_undo, 31		; Ctrl-"_"
	bind do_mx, 0			; default: define or look for macro


;;; `dimension` structure:
;;;
;;; This block of variables consists of pairs of (x, y) values corresponding
;;; to window size parameters and limits.  It can be accessed as separate
;;; interleaved strucutures: one which tells everything about X dimensions,
;;; one which does the same for y dimensions.  (That is how set_dimensions
;;; works -- it performs limit checking on the X values the same way it
;;; performs the limit checking on Y values.)

dimension struc [si]
	d_offs	db 2 dup ?
	d_cols	db 2 dup ?
	d_max	db 2 dup ?
	d_wid	db ?
ends
