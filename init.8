; init.8
; Data and macros.  Appears first in the list of modules to assemble.

; dimension struc:
;    This block of variables consists of pairs of (x,y) values corresponding
; to window size parameters and limits.  It can be accessed as separate
; interleaved strucutures: one which tells everything about X dimensions,
; one which does the same for y dimensions.  (That is how set_dimensions
; works -- it performs limit checking on the X values the same way it
; performs the limit checking on Y values.)

dimension struc [si]
	d_offs	db 2 dup ?
	d_cols	db 2 dup ?
	d_max	db 2 dup ?
	d_wid	db ?
ends

EOT_CHAR	equ 236	; Omega character; displayed at end of text
maxline		equ 48
STACKSIZE	equ 256
MX_BUF_SIZE	equ 300	; 1 byte/keystroke, 2 bytes/macro, 2 bytes/nest level
SRCH_SIZE	equ 32	; Warning: each character needs 6 bytes of stack...
FNAME_SIZE	equ 07E ; maximum size of file name


data segment
	; These variables should overlap this once-used 3-byte jmp instruction.
	org 0100h
	cursor		label word
	cursorX 	db ?
	cursorY 	db ?
	clrstat		db ?		; controls clearing of status line

code segment

main:	jmp start

color		db ?		; current color

EVEN

; ** These values are accessed in order during initialization of memory **
; ** Check initialization code before re-ordering these **
;    They are organized in descending order to be assigned when calculated.
dyn_buffers:
mxstackmax	dw		; same as mxmax
mxmax		dw ?		; end of macro data buffer region
mxstackmin	dw		; same as mxbtm (indicates limit of stack size)
mxbtm		dw ?		; end of definitions (starts = mxbuf)
mxbuf		dw		; position of macro buffer (same as srch_max)
srch_max	dw ?		; srchstr + SRCH_SIZE = mxbuf
srchstr		dw ?		; start of search string buffer
fname_buf	dw		; temp fname; starts where text buffer ends
text_limit	dw ?		; maximum value for text_btm

;;
;;  srch.8 variables:
;;
srchend		dw ?		; ptr to end of srchstr[]
srchdir_n_mask	dw
srchdir		db ?		; search direction
srchcsmask	db ?		; 0FF if case sensitive, 95 if not
srchtextmax	dw ?		; = text_btm - len(srchstr)
; srchmode, when set, indicates that a replace operation is taking place,
;    so that the search code can behave accordingly.  Further, a certain value
;    of srchmode indicates that the replace operation is in "replace all" mode.
;    Also, srchmode is set while a replace macro is being recorded so
;    ctrl-S can be interpreted to mean "stop recording".
srchmode	db ?		; 3 => already in search/replace
				; 4 => srch/replace ALL occurrences
srcholdlen	dw 0		; 0 => no previous search string

;;
;;  Undo buffer
;;

ub_end		dq
ub_pos		dw ?
ub_seg		dw 0		; ub_init assumes ub_limit follows ub_seg.
ub_limit	dw ?
ub_undo_pos	dw ?

;;
;;  Cut buffer
;;

; Order of these cut buffer variables is important; cb_init assumes
; that cb_limit follows cb_seg.
cb_end		dq
cb_size		dw 0		; number of bytes in the cut buffer
cb_seg		dw ?		; segment pointer to start of cut buffer
cb_limit	dw ?		; maximum size of the cut buffer

physline	dw ?		; value calculated by advance_to_di
err_sp		dw ?		; stores SP for catch_error() and jmp_error()


topleft		label word	; A quick way to access xoff and yoff
xoff		db 0		; (xoff,yoff) is an offset to which all other
yoff		db 0		;    (x,y) coordinates are relative.
disp_cols	db 0		; set by '-w' argument (width of window)
disp_lines	db 0		; set by '-l' argument (# lines in window)
maxX		db ?		; = disp_cols-1	(highest column # for text)
maxY		db ?		; = disp_lines-1 (highest line # for text)
hgt_and_wid	dw
scrwid		db 0		; screen width in columns (set on startup)
scrhgt		db 0		; screen height in lines (set by '-L')

screen_seg	dw
		db 0
screen_page	db 0		; If screen_page == 0 then write to screen buf
				; (When non-zero, screen_seg holds screen mem)


;;
;;  key.8 variables:
;;
mxptr		dw ?	; playback pointer (0 => playback off)
				; Points to character getkey will return
mxrecptr	dw ?	; record pointer  (0 => not recording)
				; mxrecptr points to next place to store a char
mxsp		dw		; same as mxlimit (bottom of stack)
mxlimit		dw ?		; limit for macro definitions (starts = mxmax)
ungotkey	db 0

; These variables pertain to the current state of the editor.
; (as does cursor)

targetX		db 0		; stores column for goto next/prev line fns.

verbatim	db 0		; >0 if CR's should be displayed, 0 if not
dispmode	db 0		; Specifies representation of ctrl chars



changes		label word	; Set 'unsaved' and 'deleted' at one time
unsaved		db 0		; 0FFh if there are unsaved changes
deleted		db 0		; set when the previous function deleted text
wnd_ptr		dw ?		; = Where in text the top-left of screen is.
wnd_drawn	dw ?		; value of 'wnd_ptr' at time of last disp_page
point		dw ?		; Current edit point in text (where cursor is)
text_mark	dw 0		; Current mark setting (0 indicates not set)
text_btm	dw text_top	; Points to byte after end of text.

; These variables affect the manner in which text is displayed.

defcolor	db 0Eh		; default color
hlt_and_inv	dw		; get hlt and inv at once
hltcolor	db 7		; highlighted color
invcolor	db 020h		; inverse color
;;hltcolor	db 9		; highlighted color
;;invcolor	db 01Eh		; inverse color
tabwid		db 8		; "-tX" changes this.
tabchar		equ 9		; this is not modifiable at present
crlf		db 13		; Used by save_file().  (If newline changes,
		;db 10		; then verbatim is set & crlf won't be used!)
newline		db 10		; character denoting end of logical line (-nX)
				; If "-n.." is given, verbatim should be set!



; Menu definition:
; Lower case typed letters are converted to upper before checking for match

menudef MACRO
#1menu:	db #2, 0		; #1 = label prefix,  #2 = menu prompt
	db #3			; #3 = no. of menu options
	dw #1menuL		; label for list of action letters
  #rx4l
	dw #x			; jump vectors for actions  (4, 6, 8, ...)
  #e2
  #ry5l
	db #y,0			; strings for actions	(#5, 7, 9, ...)
  #e2
#1menuL: db			; define label for list of action letters
#EM

dvect MACRO db #1, (#2 - $ - 1) #EM

jmps MACRO jmp short #1 #EM

clear MACRO sub #1,#1 #EM

shr4 MACRO shr #1,4 #EM		; redefine to be 286 specific or not

pushi MACRO push #1 #EM		; 286 specific or not.  Since the 8086 version
				; might use AX, use this as if it trashes AX.

clc_skip1 MACRO db 0A8h #EM	; "test al,ib" : Clears carry, skips next byte

skip2 MACRO db 0a9h #EM		; "test ax, im"... next 2 bytes are imm data

ungetkey MACRO mov ungotkey,#1 #EM

jmpon MACRO
	cmp al,#1
	jz #2
#EM

bind MACRO #rx2l
	db  #x		; byte representing key
	dw  offset #1	; word holding associated value
  #er
#em

;; Message indices:
msgfilesaved	equ 1
msgnewfile	equ 2
msgtextfull	equ 16
msgcutfull	equ 4
msgmarkset	equ 5
msgmarknot	equ 6
msgaborted	equ 7

msgmxfull	equ 8
msgrecording	equ 9
msgmxdone	equ 10
msgloop		equ 11

; srch_input benefits from this property:  msgrsrch AND 3 == msgrplc
;					   msgsrch AND 3 == msgrplc
;				 Also:	   msgedit == 3
msgrsrch	equ 12	; "R-Search:"
msgsrch		equ 14	; "Search:"  (== msgrsrch + 2)
msgfull		equ 13	; "(full):"
msgrplc		equ 15	; "Replace? ..."
msgedit		equ 3	; "Press Ctrl-S when done..."
msgnotfound	equ 17	; srch_more needs (msgnotfound > other msgs)

msgloadfile	equ 26
msgsavefile	equ 27
msgreaderror	equ 28
msgfilebig	equ 29
msgerrorsaving	equ 30
msgloaded	equ 36
msgnomore	equ 42
msgundo		equ 43

dosmsg3:	db 'TM: bad argument$'
dosmsg4:	db 'TM: Not enough memory$'
banner:	db 'TM 1.4, copyright 1992 Brian Kelley'
msg0:	db 0
msgfilesaved_addr:
	db -39,'d',-40,0		; 1 = 'Saved "<fnm>"'
	db 'New',-31,-40,0		; 2 = 'New file: "<fnm>"'
	db 'Type ^S when done...',0	; 3 (was 16)
	db 'Cut',-20,0			; 4 = 'Cut buffer full!'
	db -21,'set.',0			; 5 = 'Mark set.'
	db -21,-22,'set!',0		; 6 = 'Mark not set!'
	db '^G',0			; 7 = '^G'
	db -23,-20,0			; 8 = 'Macro buffer full!'
	db -25,-41,-23,'...',0		; 9 = 'Recording macro...'
	db -23,' ',-25,-18,0		; 10 = 'Macro recorded.'
	db -23,' loop!',0		; 11 = 'Macro loop!'
		;  Search messages, 12...17 (numbering is significant)
	db 'R-', -14, 0			; 12 = 'R-Search:'
	db -19, ' :', 0			; 13 = 'Full! :'
	db 'Search:',0			; 14
	db -38,'? (Y,N,A,Q) :',0	; 15 = 'Replace? (Y,N,A,Q) :'
	db -33,-20,0			; 16 (was 3) = 'File buffer full!'
	db -22,'found:',0		; 17 = 'Not found:'
	db 'ed.', 0			; 18 (î)  Keep?
	db 'full!', 0			; 19
	db ' buffer ', -19, 0		; 20 = ' buffer full!'
	db 'mark ', 0			; 21
	db 'not ',0			; 22
	db 'macro', 0			; 23
	db 'Quit', 0			; 24 (è)
	db 'record', 0			; 25
	db -35,-31,0			; 26 = 'Load file:'
	db -39,-31,0			; 27 = 'Save file:'
	db -35,' ',-32,'!',0		; 28 = 'Load error!'
	db -33,' too big!',0		; 29 = 'File too big!'
	db -32,' ',-34,-41,-33,'!',0	; 30 = 'Error saving file!'
	db ' ',-33,':',0		; 31 = ' file:'
	db 'error',0			; 32
	db 'file',0			; 33
	db 'sav',0			; 34 (Þ)
	db 'Load',0			; 35 (Ý)
	db -35,'ed',-40,0		; 36 = 'Loaded "<fnm>"'
	db ' changes',0			; 37 = ' changes'  (Û)
	db 'Replace',0			; 38 = 'Replace'   (Ú)
	db 'Save',0			; 39 (Ù)
	db ' "',-128,'"',0		; 40 = '"<fname>"' (Ø)
	db 'ing ',0			; 41
	db 'no more ',-44,'!',0		; 42
	db -44,-41,'...',0		; 43
	db 'undo',0			; 44

menudef ESC, 'Option:', 4, save_file, -39, save_as, 'Þe As', find_file, -35, chk_exit, -24
	bind 1, 'S',19			; 'S' and ctrl-S execute "Save"
	bind 2, 'A',23			; 'A' and ctrl-W execute "save As"
	bind 3, 'L',6			; 'L' and ctrl-F execute "Load"
	bind 4, 'Q',3			; 'Q' and ctrl-C execute option 2
	db 0

menudef EXIT, 'è and loseÛ?', 2, menuret, 'No', exit_to_dos, 'Yes'
	bind 1, 'N'
	bind 2, 'Y'
	db 0

menudef LOAD, 'Ý:Ø unÞî', 2, save_and_find, 'ÙÛ', load_named, 'Ú'
	bind 1, 'S'
	bind 2, 'R'
	db 0
	

; Key bindings:
;    When a special key (a non-printable one) is typed, this list of
; key bindings is searched for a function to execute.  Control characters
; are represented by their usual value; extended codes are represented
; by their second byte only.
;    Bindings are stored as a sequential list of (key,function) pairs, but
; are written in a more convenient and abbreviated style using a macro:
; "bind <fn>, key1, key2, ..."  generates (key1,fn), (key2,fn), ..., pairs.
;    A zero byte (in the place of a key) terminates the list of bindings.

fn_bindings:
	bind do_literal, 10		; LF
	bind do_enter, 13		; Enter
	bind do_tab, 9			; tab
	bind do_backspace, 8		; BackSpace
	bind go_up, 16, -72		; ctrl-P, Up
	bind go_dn, 14, -80		; ctrl-N, Down
	bind go_lft, 2, -75		; ctrl-B, Left
	bind go_rgt, 6, -77		; ctrl-F, Right
	bind go_pgup, -73, -47		; PgUp, alt-V
	bind go_pgdn, -81, 22		; PgDn, ctrl-V
	bind go_top, -4			; ctrl-PgUp (-132 -> -4)
	bind go_btm, -118		; ctrl-PgDn
	bind go_home, 1, -71		; ctrl-A, Home
	bind go_end, 5, -79		; ctrl-E, End
	bind go_lft_word, -115, -48	; ctrl-Left, Alt-B
	bind go_rgt_word, -116, -33	; ctrl-Right, Alt-F
	bind go_scrlup, 26		; ctrl-Z
	bind go_scrldn, -44		; alt-Z
	bind recenter, 12		; ctrl-L
	bind do_delete, 4, -83		; ctrl-D, Delete
	bind do_kill, 11, -117		; ctrl-K, ctrl-End
	bind do_ctrlq, 17		; ctrl-Q
	bind menu1, 24, 27		; ctrl-X, ESC
	bind do_yank, 25		; ctrl-Y
	bind do_cutappend, -30		; Alt-A
	bind do_setmark, -3		; Ctrl-@, Alt-= (-131 -> -3)
	bind do_deltomark, 23		; Ctrl-W
	bind do_fsearch, 19		; Ctrl-S
	bind do_rsearch, 18		; Ctrl-R
	bind do_xchgmark, 28		; Ctrl-\
	bind do_abort, 7		; Ctrl-G
	bind do_stripCRs, -50		; Alt-M
	bind do_twiddle, 20		; Ctrl-T
	bind do_dispmode, -34		; Alt-G
	bind do_insline, 15		; Ctrl-O
	bind do_undo, 31		; Ctrl-"_"
	bind do_mx, 0			; default: define or look for macro
