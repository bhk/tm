TM, version 1.5

Notable features:

  1. Small.
  2. Configurable.  On the command line, you can specify:
	- line separator (UNIX vs. DOS vs. arbitrary character)
	- window size & position
	- use of BIOS vs. direct access to any area of memory
	- tab-stop separation
	- color scheme
  3. Powerful features:
	- easily-definable macros
	- incremental search & replace
	- "unlimited" undo
	- display modes for control & graphics characters
  4. Support for many Emacs key bindings.
  5. Long lines are displayed wrapped, not truncated.


Usage:

   "TM [switches] file"

   Valid switches:
	-x# : leftmost column on screen to use (0 by default)
	-y# : topmost line on screen to use (0 by default)
	-l# : number of lines to use (defaults to maximum)
	-w# : number of columns to use (defaults to maximum)
	-L# : how many lines fit on the screen (default = 25)
              A BIOS call reveals how many columns there are, but
	      there is no such call to inquire about lines.
	-c# : specify regular color
	-i# : specify inverse color
	-h# : specify highlight color
	-n# : Specify character to use as newline.
	-t# : specify tab-stop spacing (default = 8)
	-b  : force TM to use BIOS to access screen.  TM normally
              writes directly to the screen buffer if the display
	      type reported by BIOS is recognized.
	-b# : force TM to skip BIOS and write to screen memory at
	      segment page `#`.  For example, "-b0b8" corresponds
	      to segment B800H, the CGA screen buffer.  Note that
              improper use of this option can crash the computer.


  `#` represents a number.  An initial `0` indicates hexadecimal.


Basic Functionality, and Command Keys:

   TM is a modeless, visual editor.  It fills the screen with the
contents of the file being edited, indicating the end of the file
with a "ì" symbol, and places the cursor at the "point" (the spot
where text will be inserted).  Typing characters will insert them
into the document, and special keys and modifier keys are used to
invoke editing functions and navigate through the text.

   The notation "^K" refers to pressing "K" while the Control key
is held down, and "Alt-K" means pressing "K" while the Alt key is
held down.


   Here is a summary of the editing functions in TM and what keys
invoke them:

   Arrow keys	: Move the cursor in the corresponding direction.
   ^Left/^Right	: Move left/right by one word.
   PgUp/PgDn	: Page up/down through the text.
   ^PgUp/^PgDn	: Move to top/bottom of text.
   Del		: Delete the character at the cursor.
   BackSpace	: Delete the character before the cursor.
   End		: Move to the end of the line.
   Home		: Move to the beginning of the line.

   ^_		: "Undo" last modification to the test buffer.

   ^O		: Insert line after point
   ^T		: Swap the characters before and after the point.
   ^L		: Centers point on screen.
   ^End		: Delete to end-of-line.
   ^Z / Alt-Z	: Scroll text down/up one line on scren.
   ^Q		: "Quotes" the next character typed.  (Even if it
		  is a control character it will be inserted into
                  the text and not interpreted as a command.)
   ^S		: Start incremental search for a string.
   ^R		: Start reverse incremental search.
   ^Y		: Yank (undelete) deleted text.
   Alt-A	: Set "append-to-cut-buffer" flag.
   ^@/^SPC	: Set mark to current point in text.
   ^W		: "Wipe." Delete text from current point to mark.
   Alt-Fx	: Start/finish recording macro for F1 .. F10.
   Fx		: "play back" macro defined for F1 .. F10.
   Alt-G	: Toggle mode for displaying graphics characters.
		  (See "Graphics Characters", below.)
   Alt-M	: Convert newlines: remove all ^M characters from
		  a file.

   Escape, ^X	: Bring up the menu.


Menus:

    When a menu is displayed, use the arrow keys to highlight the
desired option and press Enter to select it, or you can just type
the letter capitalized in the option name.
    To exit a menu and return to editing, press Escape.


Other notes:

   When a line in the text exceeds the physical screen width, the
remaining characters continue on the next screen line.  Whereever
the text wraps to the next line, TM displays the character in the
last column in inverse video.
   When moving up and down a line at a time, the cursor moves one
physical (visible) line at a time.  However, the operations bound
to ^E, ^A, or ^K refer to logical lines, which are defined by the
occurence of newline characters in the text.


Limitations:

   The maximum file size is about 60K (or less if there is a lack
of available memory).


Graphics Characters:

   By default, characters in the file are displayed using the IBM
PC character set (except for newline and tab, which indicate line
boundaries and tab stops).
   Alternate display modes display control characters (ASCII 0 to
31) as "^@", "^A", etc., and 8-bit characters (128 to 255) with a
hexadecimal notation of the form "\XX".  There is a total of four
modes, and Alt-G steps through them.

	Mode	Control chars		Eight-bit characters
	----	-------------		--------------------
(default) 0	, , , 		É, Í, Ñ, Î

	  1	^B, ^C, ^D, ^E		É, Í, Ñ, Î

	  2	, , , 		\C9, \CD, \D1, \CE

	  3	^B, ^C, ^D, ^E		\C9, \CD, \D1, \CE


Undelete:

   When text is deleted is it stored in the "cut buffer".  If the
deletion operation immediately follows another deletion function,
then the text is appended to the existing cut buffer contents.

   ^Y "undeletes", by inserting the contents of the cut buffer at
the current cursor position, so the regular deletion commands can
be used in conjunction with ^Y in order to copy and move sections
of text.

   A typical way of using the cut buffer is:

	1. Move to the start of the text you want to move.
	2. Type ^End or Del until it is all gone.
	3. Move to where you want to place the deleted text.
	4. Type ^Y.

   To copy text, you can "delete-undelete-move-undelete".

   Typing Alt-A modifies this behavior by causing the immediately
following delete operation to append to the cut buffer, even when
there had been an intervening non-delete operation before Alt-A.


Undo:

   Every time a modification is made to the text buffer, an entry
is added to the "undo buffer", so that it may be undone.  This is
true for all editing operations except Convert Newlines (Alt-M).

   Typing ^_ after a modification will "undo" it.  Typing ^_ once
more will undo the previous modification. Each successive ^_ will
step further back into the history of the editing session.

   Each undo operation is itself a modification, and is similarly
recorded in the undo buffer.  So, if you find that you go too far
and want to undo the undo, make a minor modification to reset the
undo state back to the most recent change.  At that point, typing
^_ will undo your minor modification, and then additional presses
will undo your recent undo operations.

   A fixed-size buffer holds undo information.  When it fills up,
the oldest undo records are discarded to make room for newer undo
records.  Each undo record consumes 5 bytes, plus the size of any
text that was deleted.  The undo buffer is 64KB, large enough for
about 10,000 single-byte modifications.  Each undo operation also
adds an undo record to the buffer, so after 5000 single-byte undo
operations you would run out of undo space.

Incremental Search:

   Typing ^S enters search mode.  On the status line, the current
search search string (initially empty) is displayed.  As you type
characters, they are added to the search string, and the matching
text in the document will found and displayed, placing the cursor
at the end of the match.

   When you first enter search mode, it performs case-insensitive
searches.  Typing an upper-case letter will make the search case-
sensitive, and this will remain in effect for the duration of the
search.  To match lower-case text in a case-sensitive manner, you
can type an upper-case letter and then backspace over it.

   Backspace removes charcters from the end of the search string,
and returns the text cursor to the position in the text previously
matched by that shorter search string.

   Escape exits search mode, leaving the cursor at the end of the
current match.

   ^G exits search mode, returning the cursor to the where it was
when search mode was entered.

   ^R or ^S will move to the next occurrence of the string before
(^R) or after (^S) the current match.  If there is no such match,
"Not found" will be displayed, and at that point, typing ^R or ^S
again will cause the seach to wrap around to the other end of the
document.

   ^Backspace enters Replace Mode; see "Search and Replace" below.

   All other "action" keys are executed normally, but after search
mode is exited with the point left where it is in the text.


Search and Replace:

   To replace one string of characters with another, search for a
match for the string you want to replace and then, while still in
search mode, type ^Backspace.  This deletes the currently matched
occurrence and enters macro recording mode, allowing you to enter
its replacement.  When done, type ^S to enter replace mode, which
will advance to the next occurrence and ask "Replace? (Y,N,A,Q)":

   "Y" means "yes, replace this occurrence."
   "N" means, "no, skip this occurrence."
   "A" means, "yes, and replace all following occurrences without
asking again."
   "Q" exits replace mode immediately.

   Since the "replacement" operation is in fact a recorded macro,
it may contain arbitrary editing or navigation operations, and as
with macro playback, you can type ^G to interrupt the playback or
a replace-all operation.


Finer Points of Search/Replace:

   If you record a replacement operation that is more complicated
than simply typing a replacement, it may not be obvious where the
search for the next occurrence will resume.  TM performs a simple
calculation that works as expected in the simple replacement case
and hopefully is useful in other cases:  After playing the macro,
TM will resume the search at the document offset of the beginning
of the replaced text, plus or minus the number of characters that
the macro playback inserted into (or deleted from) the document.


Macros:

   A macro is a recording of a sequence of keystrokes that can be
replayed later, as if you had typed them again, but with a single
keystroke.  Macros can be assigned to the keys F1-F10.  To record
a macro, do the following:

  1. Type Alt-F<x> to begin recording.
  2. Type anything (letters, control keys, whatever).
  3. Type Alt-F<x> again, to stop recording.

   Now, whenever you type F<x>, the keys you typed in step 2 will
be re-typed for you.  Here are a few finer points:

  1. If an error occurs when you are recording a macro -- such as
"buffer full", etc. -- the recording will be cancelled.

  2. An error that occurs during playback will cancel playback.

  3. The F<x> key you type as part of the Alt-F<x> keystroke that
begins recording determines the name of the macro -- the key that
plays it back.  Any Alt-F<x> key will terminate recording without
affecting the name of the macro.

  4. Searches can be recorded as part of macros, but initiating a
replace operation cancels any in-progress macro recording.


Nested Macros:

   Macros can invoke macros.  Nesting is allowed up to a depth of
five levels.  When a macro invokes itself or invokes a macro that
invokes it, then it is a "recursive" macro.  When a macro invokes
itself only as the last keystroke in its definition, then it is a
"tail-recursive" macro.  Tail-recursive macros are not subject to
the nesting limits, so they can repeat indefinitely until stopped
by an error or the user pressing ^G.

   While a macro is being recorded (e.g. via Alt-F1) its playback
key (e.g. F1) will have no effect at all.  When you play it back,
that recorded keystroke will invoke it recursively.


Newline Characters:

    In DOS, lines endings in text files are indicated with a two-
character sequence: CR/LF (ASCII 13 & 10).  In UNIX, line endings
use a single charcter (LF).  In TM's internal buffer, a single LF
character is used for line endings.  By default, TM, when reading
from a file, will remove all CR characters, and when writing to a
file, will output a CR prior to each LF.  This is the ONLY change
that TM makes to files when reading or writing them.

    To disable this newline processing, you can include "-n10" on
the command line, and any CR's in the file will appear at the end
of each line.  In this mode, TM can be used to edit binary files.

    One more important detail about using "-n":  The command line
is processed in order, from left to right.  When the "-n" appears
before a file name, it will affect how the file is loaded and how
it is saved, but if the "-n" appears after the file name, it will
not affect how it is loaded.  This allows for various conversions
between DOX and UNIX format.  To summarize:

   "TM file"      : Read DOS or UNIX, write in DOS format.
   "TM file -n10" : Read DOS or UNIX, write in UNIX format.
   "TM -n10 file" : CR's will be visible, write exactly as read.


Emacs key bindings emulated:

   ^<PNBF> : cursor movement
   ^A : beginning of line
   ^E : end of line
   ^D : delete character
   ^V : page down
   Alt-V : page up
   ^X ^C : exit
   ^X ^S : save file
   ^X ^F : find file
   ^X ^W : write file (save as...)
   ^K : kill to end of line.
   ^G cancels menu.
   ^Z, Alt-Z : scroll up, down one line
   ^Y undeletes.
   ^@ sets mark.
   ^W deletes to mark.
   ^T : transpose characters.
   ^O inserts a line.
   ^_ : undo.
   Alt-B, Alt-F : back/forward word

Re-bound Emacs functions:

   Alt-A : append the next delete to cut buffer.

Ways in which simple editing primitives differ from Emacs:

  ù When you type PgDn followed by PgUp the cursor will be at the
    position it was in before PgDn/PgUp (except at extremities of
    the text).  This is because page down/up operations move both
    the cursor and the window pointer down by a certain number of
    lines, whereas in EMACS the cursor is relocated to the top of
    the screen for page up/dowm operations.

  ù ^P and ^N (up and down arrows) move by physical lines (screen
    lines).  [^A and ^E still work by logical lines (delimited by
    newline characters).]

  ù When a line is too long to fit within the screen width, Emacs
    Emacs wraps the text to the next line, and indicates wrapping
    by showing a "\" in the rightmost column.  When TM wraps long
    lines, it highlights the character in the rightmost column.

  ù Search & Replace:  ^Backspace, not Alt-%, enters replace mode
    from search mode.  The "replacement" is not just a string, it
    can be an arbitrary sequence of keystrokes.

  ù Both ^X and ESC invoke a menu, but many Emacs ^X key sequence
    bindings -- ^X^F, ^X^S, ^X^C, ^X^W -- retain their meaning in
    TM.

  ù Since TM can only handle one file at a time, ^X^F may present
    a menu: "File has unsaved changes. Save file or discard?"

  ù Word-wise operations take only spaces as word delimiters, and
    both Alt-B and Alt-F leave the cursor at the start of a word.
